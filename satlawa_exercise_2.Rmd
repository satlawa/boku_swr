---
title: "Statistics with R - Exercise 2"
author: "Philipp Satlawa - h0640348"
date: "04/12/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This document contains the answered questions of exercise 2 for the course "Statistics with R".

***
```{r}
# import necessary libraries
library("matrixStats")
library("readxl")
library("data.table")
library("ggplot2")
```


## Task 1 - Robustness of mean/median

1. Compare mean and median - without outliers
```{r}
# set seed
set.seed(640348)

# sample 100% from normal distribution
x <- rnorm(n = 50 * 1000, mean = 0, sd = 1)

# rearrange vector into matrix with 1000 rows (N) and 50 columns (n)
X <- matrix(x, ncol = 50)

# calculate the mean for every sample
xAvg <- rowMeans(X)

# calculate the median for every sample
xMed <- rowMedians(X)

boxplot(xAvg, xMed)
#ggplot(xAvg, xMed) + geom_boxplot()
```
The mean estimation method provides a better fit to the underlying normally distributed population, since all random values are produced with a normally distributed random generator.


2. Compare mean and median - with outliers
```{r}
# set seed
set.seed(640348)

# sample 95% from a normal distribution and sample 5% from Exponential Distribution
x95 <- rnorm(n = 45 * 1000, mean = 0, sd = 1)
x05 <- rexp(n = 5 * 1000, rate = 0.2)

# rearrange vectors to matrices
x95 <- matrix(x95, ncol = 45)
x05 <- matrix(x05, ncol = 5)

# concatenate the two matrices into one matrix
X <- cbind(x95,x05)

# calculate the mean for every sample
xAvg <- rowMeans(X)

# calculate the median for every sample
xMed <- rowMedians(X)

boxplot(xAvg, xMed)
```
The median estimation method provides a better fit to the randomly produced dataset.
In this dataset 5% of the random values were generated by the exponential distribution generator.
These values generated by the exponential distribution generator added outliers to the normally distributed dataset. Due to the fact that the median is more robust to data with outliers the median estimation method provides a better estimation of the true mean.


## Task 2 - Estimation

1. Standard Cauchy Distribution with different sample sizes
```{r}
# set seed
set.seed(640348)
# sample 100 times from the Standard Cauchy distribution
cuy100 = rcauchy(100, location = 0, scale = 1)
# calculate mean
(mean(cuy100))
# calculate variance
(var(cuy100))

# set seed
set.seed(640348)
# sample 5000 times from the Standard Cauchy distribution
cuy5000 = rcauchy(5000, location = 0, scale = 1)
# calculate mean
(mean(cuy5000))
# calculate variance
(var(cuy5000))

# set seed
set.seed(640348)
# sample 100000 times from the Standard Cauchy distribution
cuy100000 = rcauchy(100000, location = 0, scale = 1)
# calculate mean
(mean(cuy100000))
# calculate variance
(var(cuy100000))
```

2. Observation of the Standard Cauchy Distribution depending on the sample size

from the calculated means and variance from the sample sizes 100 5000 100000 show no 


that fits with the 
mean and standard deviation of the Cauchy distribution are undefined.

***The mean and standard deviation of the Cauchy distribution are undefined. The practical meaning of this is that collecting 1,000 data points gives no more accurate an estimate of the mean and standard deviation than does a single point. ***


3. Plotting the standard normal and standard cauchy distribution
```{r}
# plot the standard normal and standard cauchy distribution as a boxplot
par(mfrow = c(1,2))
boxplot(rnorm(n = 100, mean = 0, sd = 1)) # ... function for normal boxplot
boxplot(rcauchy(n = 100, location = 0, scale = 1)) # ... function for cauchy boxplot
par(mfrow = c(1,1))
```
The Standard Cauchy Distribution has heavier tails hence the bell curve is much wider at the bottom compared to the normal distribution. This can be seen in the comparison of the of the two box plots, while the normal distributions min/max is around +/- 3, the min/max of the Standard Cauchy Distribution is around +/- 20. the wiskers and the min max are much more wildly spread (by the factor(magnetude) of 10).


## Task 3 - Working with a real data set

```{r}
#load library data.table
library("data.table")
library("readxl")
library(ggplot2)
```


1. Import data from different sources

  import from file .Rdata (R specific file type)
```{r}
# load data from file
load("~/Documents/boku/statistics_with_R/ex_02/CO2.Rdata")
# convert data.frame to data.table
datCO2 <- setDT(dat)
# check if data was properly loaded
str(dat)
```

import from file .txt (tabulator separated values)
```{r}
# load data from txt-file
data_txt <- read.table(file = "~/Documents/boku/statistics_with_R/ex_02/CO2.txt", header = TRUE, dec = ".")
str(data_txt)
```

import from file .csv (comma separated values)
```{r}
# load data from csv-file
data_csv <- read.csv(file = "~/Documents/boku/statistics_with_R/ex_02/CO2.csv", header = TRUE)
str(data_csv)
```

import from file .xlsx (MS Excel specific file type)
```{r}
# list sheets in xlsx-file
excel_sheets("~/Documents/boku/statistics_with_R/ex_02/CO2.xlsx")
# load data from xlsx-file
data_xlsx <- read_excel("~/Documents/boku/statistics_with_R/ex_02/CO2.xlsx", sheet = "Sheet 1")
# print data structure
str(data_xlsx)
```


2. Set seed to the student id
```{r}
# prepare seed
set.seed(as.numeric(format(Sys.time(), "%H%M%S")))
# set student id
id <- 640348
# set seed with student id
set.seed(id)
```


3. Data exploration
```{r}
# show the data structure
str(dat)
# show the data summary
summary(dat)
```
The provided dataset contains 6 variables (columns) and 1619494 records (rows).
The variables have the following types:

* unit: categorical Factor with 2 levels (unit abriviation)
* airpol: categorical Factor with 11 levels (chemical compound)
* airemsect: categorical Factor with 172 levels (code for the sector)
* geo: categorical Factor with 35 levels (country abrivation)
* time: discrete numerical (year)
* values: continuous numerical (the value)
  
The variable values has 5284 NA values and is the only variable that contains NA.


4. Select randomly two countries
```{r}
# create vector with all countries
geo_col <- datCO2[, unique(geo)]
# take 2 random samples
geo_c <- sample(geo_col, 2)
```


5. Filter data
```{r}
# filter data
datFilter <- datCO2[unit == "THS_T" & 
                      airpol == "GHG" & 
                      airemsect %in% c("CRF3", "CRF31", "CRF1A3") & 
                      geo %in% geo_c]
```


6. Remove columns/variables unit and airpol
```{r}
# remove variables
datFilter <- datFilter[, -c("unit", "airpol")]
```


7. Show records per country
```{r}
# 
datFilter[, .N, by = geo]
```
Both randomly picked countries have 84 observations.


8. Rename variable `airemsect` and its categorical values
```{r}
# rename values in variable "airemsect"
datFilter[airemsect == "CRF1A3", airemsect := "Transport"]
datFilter[airemsect == "CRF3", airemsect := "Agriculture"]
datFilter[airemsect == "CRF31", airemsect := "Livestock"]
# rename variable "airemsect" to "sector"
setnames(datFilter, "airemsect", "sector")
```


9. Calculate the average greenhouse gas (GHG) emission per sector
```{r}
# aggregate by variable "sector" and calculate the mean
datFilter[,.(mean(values)), by = sector, ]
```
The sector `Transport` produced by far the most greenhouse gas emissions.


10. Average GHG per sector and country
```{r}
# aggregate by variable "sector" and "geo" and calculate the mean
datFilter[,.(mean(values)), by = .(sector, geo)]
# calculate the difference in greenhouse gas emissions in the sector "Livestock"
datFilter[sector == "Livestock" & geo == "LU", .(mean(values))] - 
  datFilter[sector == "Livestock" & geo == "IS", .(mean(values))]
```
The country `BE` has higher average greenhouse gas emissions in the sector ”Livestock”.


11. Sum of the "Livestock" sector per country for the period 2000-2017
```{r}
datFilter[sector == "Livestock" & time %between% c(2000, 2017), .(sum(values)), by = .(geo)]
```
The sector "Livestock" produced:
* x in the country 'BE'
* x in the country 'BE'
for the period 2000-2017.


12. Plotting the GHG emissions of ”Transportation” sector for both countries
```{r}
ggplot(data=datFilter[sector == "Transport"], aes(x=time, y=values, color=geo)) + geom_line()
```